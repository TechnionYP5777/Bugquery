<?xml version="1.0" encoding="UTF-8" standalone="no"?><posts><post answer="&lt;p&gt;when you call any terminal operation the stream is closed, You could use stream supplier to construct a new stream&lt;/p&gt;&amp;#xA;&amp;#xA;&lt;pre&gt;&lt;code&gt;Supplier&amp;lt;Stream&amp;lt;String&amp;gt;&amp;gt; streamSupplier =&amp;#xA;            () -&amp;gt; Stream.of(&quot;abc&quot;, &quot;aef&quot;, &quot;bcd&quot;, &quot;bef&quot;, &quot;crf&quot;);&amp;#xA;&amp;#xA;            streamSupplier.get().filter(s -&amp;gt; s.startsWith(&quot;a&quot;)).forEach(System.out::println);&amp;#xA;            streamSupplier.get().filter(s -&amp;gt; s.startsWith(&quot;b&quot;)).forEach(System.out::println);&amp;#xA;&lt;/code&gt;&lt;/pre&gt;&amp;#xA;" question="&lt;p&gt;I want to find out &lt;code&gt;String&lt;/code&gt;s starting with a particular character using the same &lt;code&gt;Stream&lt;/code&gt; twice, but the second &lt;code&gt;Stream&lt;/code&gt; operation is throwing an exception. How can I re-use the &lt;code&gt;Stream&lt;/code&gt;?   &lt;/p&gt;&amp;#xA;&amp;#xA;&lt;pre&gt;&lt;code&gt;public static void main(String[] args) {&amp;#xA;    Stream&amp;lt;String&amp;gt; stream = Stream.of(&quot;abc&quot;, &quot;aef&quot;, &quot;bcd&quot;, &quot;bef&quot;, &quot;crf&quot;);&amp;#xA;    stream.filter(s -&amp;gt; s.startsWith(&quot;a&quot;)).forEach(System.out::println);;&amp;#xA;    stream.filter(s -&amp;gt; s.startsWith(&quot;b&quot;)).forEach(System.out::println);;&amp;#xA;}&amp;#xA;&lt;/code&gt;&lt;/pre&gt;&amp;#xA;&amp;#xA;&lt;p&gt;Exception&lt;/p&gt;&amp;#xA;&amp;#xA;&lt;pre&gt;&lt;code&gt;Exception in thread &quot;main&quot; java.lang.IllegalStateException: stream has already been operated upon or closed&amp;#xA;    at java.util.stream.AbstractPipeline.&amp;lt;init&amp;gt;(Unknown Source)&amp;#xA;    at java.util.stream.ReferencePipeline.&amp;lt;init&amp;gt;(Unknown Source)&amp;#xA;    at java.util.stream.ReferencePipeline$StatelessOp.&amp;lt;init&amp;gt;(Unknown Source)&amp;#xA;    at java.util.stream.ReferencePipeline$2.&amp;lt;init&amp;gt;(Unknown Source)&amp;#xA;    at java.util.stream.ReferencePipeline.filter(Unknown Source)&amp;#xA;    at StreamExp.main(StreamExp.java:13)&amp;#xA;&lt;/code&gt;&lt;/pre&gt;&amp;#xA;" stacktrace="Exception in thread &quot;main&quot; java.lang.IllegalStateException: stream has already been operated upon or closed&#10;    at java.util.stream.AbstractPipeline.&amp;lt;init&amp;gt;(Unknown Source)&#10;    at java.util.stream.ReferencePipeline.&amp;lt;init&amp;gt;(Unknown Source)&#10;    at java.util.stream.ReferencePipeline$StatelessOp.&amp;lt;init&amp;gt;(Unknown Source)&#10;    at java.util.stream.ReferencePipeline$2.&amp;lt;init&amp;gt;(Unknown Source)&#10;    at java.util.stream.ReferencePipeline.filter(Unknown Source)&#10;    at StreamExp.main(StreamExp.java:13)"/><post answer="&lt;p&gt;Struts is open source. Just check the &lt;code&gt;RequestProcessor&lt;/code&gt; source prior to line 658 (as noted in stacktrace):&lt;/p&gt;&amp;#xA;&amp;#xA;&lt;pre&gt;&lt;code&gt;// No mapping can be found to process this request&amp;#xA;String msg = getInternal().getMessage(&quot;processInvalid&quot;, path);&amp;#xA;log.error(msg);&amp;#xA;response.sendError(HttpServletResponse.SC_NOT_FOUND, msg);&amp;#xA;&lt;/code&gt;&lt;/pre&gt;&amp;#xA;&amp;#xA;&lt;p&gt;See the comment: &lt;code&gt;No mapping can be found to process this request&lt;/code&gt;. That's the root cause of the problem. But the &lt;code&gt;sendError()&lt;/code&gt; call to display an error message cannot be completed as well, because the response is already committed. Apparently there are two things a failure: there's a mapping missing and the default work of Struts mapping has been taken over programmatically in an incorrect manner.&lt;/p&gt;&amp;#xA;" question="&lt;p&gt;I continuously get below error on my weblogic 10.3 console logs&lt;/p&gt;&amp;#xA;&amp;#xA;&lt;pre&gt;&lt;code&gt;java.lang.IllegalStateException: Response already committed&amp;#xA;at weblogic.servlet.internal.ServletResponseImpl.objectIfCommitted(ServletResponseImpl.java:&amp;#xA;1462)&amp;#xA;at weblogic.servlet.internal.ServletResponseImpl.sendError(ServletResponseImpl.java:601)&amp;#xA;at org.apache.struts.action.RequestProcessor.processMapping(RequestProcessor.java:658)&amp;#xA;at org.apache.struts.action.RequestProcessor.process(RequestProcessor.java:193)&amp;#xA;at org.apache.struts.action.ActionServlet.process(ActionServlet.java:1164)&amp;#xA;&lt;/code&gt;&lt;/pre&gt;&amp;#xA;&amp;#xA;&lt;p&gt;Truncated. see log file for complete stacktrace&lt;/p&gt;&amp;#xA;&amp;#xA;&lt;p&gt;I was wondering what harm is caused by this if left unfixed ? This error has been in my app before I joined the team, is this serious enough to qualify as &quot;Needs immediate fix&quot; ?&lt;/p&gt;&amp;#xA;" stacktrace="java.lang.IllegalStateException: Response already committed&#10;at weblogic.servlet.internal.ServletResponseImpl.objectIfCommitted(ServletResponseImpl.java:"/><post answer="&lt;p&gt;Ok, here is what I did:&lt;/p&gt;&amp;#xA;&amp;#xA;&lt;ol&gt;&amp;#xA;&lt;li&gt;Get Tomcat 6.0.26&lt;/li&gt;&amp;#xA;&lt;li&gt;&lt;p&gt;Checkout the petclinic sample: &lt;/p&gt;&amp;#xA;&amp;#xA;&lt;pre&gt;&lt;code&gt;svn co https://src.springframework.org/svn/spring-samples/petclinic/trunk/ petclinic&amp;#xA;&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;&amp;#xA;&lt;li&gt;&lt;p&gt;&lt;code&gt;cd&lt;/code&gt; into the petclinic directory&lt;/p&gt;&lt;/li&gt;&amp;#xA;&lt;li&gt;Modify &lt;code&gt;src/main/webapp/WEB-INF/spring/applicationContext-jpa.xml&lt;/code&gt; to use Hibernate:&amp;#xA;&lt;ul&gt;&amp;#xA;&lt;li&gt;COMMENT the &lt;code&gt;&amp;lt;context:load-time-weaver&amp;gt;&lt;/code&gt; (&lt;a href=&quot;http://static.springsource.org/spring/docs/3.0.x/spring-framework-reference/html/orm.html#orm-jpa-setup-lcemfb&quot;&gt;load-time weaver &lt;strong&gt;SHOULD NOT&lt;/strong&gt; be used with Hibernate&lt;/a&gt;, this is for Toplink)&lt;/li&gt;&amp;#xA;&lt;li&gt;Declare Hibernate as &lt;code&gt;jpaVendorAdapter&lt;/code&gt; (comment the Toplink part, uncomment the Hibernate part)&lt;/li&gt;&amp;#xA;&lt;/ul&gt;&lt;/li&gt;&amp;#xA;&lt;li&gt;Modify the &lt;code&gt;src/main/webapp/WEB-INF/web.xml&lt;/code&gt; to use the &lt;code&gt;applicationContext-jpa.xml&lt;/code&gt;&lt;/li&gt;&amp;#xA;&lt;li&gt;&lt;p&gt;Modify the &lt;code&gt;pom.xml&lt;/code&gt; to bundle &lt;strong&gt;jta.jar&lt;/strong&gt; in the war (as pointed out by @skaffman):&lt;/p&gt;&amp;#xA;&amp;#xA;&lt;pre&gt;&lt;code&gt;&amp;lt;dependency&amp;gt;&amp;#xA;  &amp;lt;groupId&amp;gt;javax.transaction&amp;lt;/groupId&amp;gt;&amp;#xA;  &amp;lt;artifactId&amp;gt;com.springsource.javax.transaction&amp;lt;/artifactId&amp;gt;&amp;#xA;  &amp;lt;version&amp;gt;1.1.0&amp;lt;/version&amp;gt;&amp;#xA;  &amp;lt;!--scope&amp;gt;test&amp;lt;/scope--&amp;gt;&amp;#xA;&amp;lt;/dependency&amp;gt;&amp;#xA;&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;&amp;#xA;&lt;li&gt;&lt;p&gt;Build the war&lt;/p&gt;&amp;#xA;&amp;#xA;&lt;pre&gt;&lt;code&gt;mvn install&amp;#xA;&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;&amp;#xA;&lt;li&gt;&lt;p&gt;Deploy it to Tomcat&lt;/p&gt;&amp;#xA;&amp;#xA;&lt;pre&gt;&lt;code&gt;cp target/petclinic.war $TOMCAT_HOME/webapps&amp;#xA;&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;&amp;#xA;&lt;li&gt;&lt;p&gt;Browse&lt;/p&gt;&amp;#xA;&amp;#xA;&lt;pre&gt;&lt;code&gt;http://localhost:8080/petclinic&amp;#xA;&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;&amp;#xA;&lt;/ol&gt;&amp;#xA;" question="&lt;p&gt;OK, this probably is supposed to be the easiest thing in the world, but I've been trying for the entire day, and it's still not working.. Any help is highly appreciated!  &lt;/p&gt;&amp;#xA;&amp;#xA;&lt;p&gt;EDIT: &lt;strong&gt;For the correct procedure, please see Pascal's answer.&lt;/strong&gt; &lt;/p&gt;&amp;#xA;&amp;#xA;&lt;p&gt;My wrong (since I did not disabled LoadTimeWeaving) procedure is left for reference..:&lt;/p&gt;&amp;#xA;&amp;#xA;&lt;p&gt;What I did:&lt;/p&gt;&amp;#xA;&amp;#xA;&lt;ol&gt;&amp;#xA;&lt;li&gt;Downloaded Tomcat 6.0.26 &amp;amp; Spring 3.0.1&lt;/li&gt;&amp;#xA;&lt;li&gt;Downloaded PetClinic from &lt;a href=&quot;https://src.springframework.org/svn/spring-samples/petclinic&quot;&gt;https://src.springframework.org/svn/spring-samples/petclinic&lt;/a&gt;&lt;/li&gt;&amp;#xA;&lt;li&gt;Built &amp;amp; deployed petclinic.war. Ran fine with default JDBC persistence.&lt;/li&gt;&amp;#xA;&lt;li&gt;Edited webapps/WEB-INF/spring/applicationContext-jpa.xml and set &lt;code&gt;jpaVendorAdaptor&lt;/code&gt; to Hibernate.&lt;/li&gt;&amp;#xA;&lt;li&gt;Edited webapps/WEB-INF/web.xml and changed &lt;code&gt;context-param&lt;/code&gt; from applicationContext-jdbc.xml to applicationContext-jpa.xml&lt;/li&gt;&amp;#xA;&lt;li&gt;Copied everything in the Spring 3.0.1 distribution to TOMCAT_HOME/lib. &lt;/li&gt;&amp;#xA;&lt;li&gt;&lt;p&gt;Launched tomcat. Saw &lt;/p&gt;&amp;#xA;&amp;#xA;&lt;p&gt;Caused by: java.lang.IllegalStateException: ClassLoader [org.apache.catalina.loader.WebappClassLoader] does NOT provide an 'addTransformer(ClassFileTransformer)' method. Specify a custom LoadTimeWeaver or start your Java virtual machine with Spring's agent: -javaagent:spring-agent.jar&lt;/p&gt;&lt;/li&gt;&amp;#xA;&lt;li&gt;&lt;p&gt;Uncommented line &lt;code&gt;&amp;lt;Loader loaderClass=&quot;org.springframework.instrument.classloading.tomcat.TomcatInstrumentableClassLoader&quot;/&amp;gt;&lt;/code&gt; in webapps/META-INF/context.xml.&lt;/p&gt;&lt;/li&gt;&amp;#xA;&lt;li&gt;Same error. Added that line to TOMCAT_HOME/context.xml&lt;/li&gt;&amp;#xA;&lt;li&gt;&lt;p&gt;Deployed without error. However, when I do something it will issue an error saying&lt;/p&gt;&amp;#xA;&amp;#xA;&lt;p&gt;&lt;code&gt;java.lang.NoClassDefFoundError: javax/transaction/SystemException at org.hibernate.ejb.EntityManagerFactoryImpl.createEntityManager(EntityManagerFactoryImpl.java:39)&lt;/code&gt; &lt;/p&gt;&amp;#xA;&amp;#xA;&lt;p&gt;11.Changed scope of javax.transaction from test to default (just deleted test), as suggested by scaffman.&lt;/p&gt;&amp;#xA;&amp;#xA;&lt;p&gt;12.Runs fine!! Thank you!&lt;/p&gt;&lt;/li&gt;&amp;#xA;&lt;/ol&gt;&amp;#xA;" stacktrace="Caused by: java.lang.IllegalStateException: ClassLoader [org.apache.catalina.loader.WebappClassLoader] does NOT provide an 'addTransformer(ClassFileTransformer)' method. Specify a custom LoadTimeWeaver or start your Java virtual machine with Spring's agent: -javaagent:spring-agent.jar"/><post answer="&lt;blockquote&gt;&amp;#xA;  &lt;p&gt;The reason I am trying to separate the controller for generating the form from the controller saving the form because I am using Springs &lt;code&gt;@ExceptionHandler&lt;/code&gt; to handle any runtime exceptions that occur, and I would like to handle an exception for displaying the view differently than an exception for saving a record&lt;/p&gt;&amp;#xA;&lt;/blockquote&gt;&amp;#xA;&amp;#xA;&lt;p&gt;I would imagine that your view template engine would throw exceptions of a different type hierarchy than exceptions encountered while saving records in your datastore. It may be easiest to place these methods in the same class, and then just address your &lt;code&gt;@ExceptionResolver&lt;/code&gt; concern by mapping exceptions of the view engine's type one way, and DB exceptions another.&lt;/p&gt;&amp;#xA;" question="&lt;p&gt;I am using Spring MVC with annotation configuration.  I have a controller class for handling HTTP GET calls:&lt;/p&gt;&amp;#xA;&amp;#xA;&lt;pre&gt;&lt;code&gt;@Controller&amp;#xA;@RequestMapping(&quot;/form&quot;)&amp;#xA;public class FormController {&amp;#xA;&amp;#xA;    @RequestMapping(value = &quot;/{table}/{identifier}/edit&quot;, method = RequestMethod.GET)&amp;#xA;    public ModelAndView getEditView(ModelMap map, @PathVariable String table, @PathVariable Object identifier) {&amp;#xA;        //generate the view for this record&amp;#xA;    }&amp;#xA;&lt;/code&gt;&lt;/pre&gt;&amp;#xA;&amp;#xA;&lt;p&gt;and a Controller for processing form submits on that URL&lt;/p&gt;&amp;#xA;&amp;#xA;&lt;pre&gt;&lt;code&gt;@Controller&amp;#xA;@RequestMapping(&quot;/form&quot;)&amp;#xA;public class FormSaveController {&amp;#xA;&amp;#xA;    @RequestMapping(value = &quot;/{table}/{identifier}/edit&quot;, method = RequestMethod.POST)&amp;#xA;    public ModelAndView saveView(WebRequest request, @PathVariable String table, @PathVariable Object identifier) {&amp;#xA;        //save the updated values and redirect to view&amp;#xA;    }&amp;#xA;&lt;/code&gt;&lt;/pre&gt;&amp;#xA;&amp;#xA;&lt;p&gt;When I attempt to startup my container, spring complains &lt;/p&gt;&amp;#xA;&amp;#xA;&lt;pre&gt;&lt;code&gt;Caused by: java.lang.IllegalStateException: Cannot map handler 'FormSaveController' to URL path [/form/{table}/{identifier}/edit]: There is already handler of type [class com.company.web.FormController] mapped.&amp;#xA;&lt;/code&gt;&lt;/pre&gt;&amp;#xA;&amp;#xA;&lt;p&gt;This seems to indicate what I'm trying to do is not supported in Spring. The reason I am trying to separate the controller for generating the form from the controller saving the form because I am using Springs &lt;code&gt;@ExceptionHandler&lt;/code&gt; to handle any runtime exceptions that occur, and I would like to handle an exception for displaying the view differently than an exception for saving a record.&lt;/p&gt;&amp;#xA;&amp;#xA;&lt;p&gt;Is there a different way of handling what I am trying to do (utilize Springs &lt;code&gt;@ExceptionHandler&lt;/code&gt; annotation for specific kinds of request?)&lt;/p&gt;&amp;#xA;" stacktrace="Caused by: java.lang.IllegalStateException: Cannot map handler 'FormSaveController' to URL path [/form/{table}/{identifier}/edit]: There is already handler of type [class com.company.web.FormController] mapped."/><post answer="&lt;p&gt;When you push the Attributes onto your custom object stack, you are taking the actual Attributes object, which, according to the &lt;a href=&quot;http://www.saxproject.org/apidoc/org/xml/sax/ContentHandler.html#startElement%28java.lang.String,%20java.lang.String,%20java.lang.String,%20org.xml.sax.Attributes%29&quot; rel=&quot;nofollow&quot;&gt;documentation&lt;/a&gt; says this:&lt;/p&gt;&amp;#xA;&amp;#xA;&lt;p&gt;atts - the attributes attached to the element. If there are no attributes, it shall be an empty Attributes object. &lt;strong&gt;The value of this object after startElement returns is undefined&lt;/strong&gt; (emphasis mine)&lt;/p&gt;&amp;#xA;&amp;#xA;&lt;p&gt;You should instead, in your startElement(...) method capture the attributes in a Map&amp;lt;String,String&amp;gt;.  This way you can use them where ever you want to.&lt;/p&gt;&amp;#xA;" question="&lt;p&gt;I'm trying to store the current document position in a stack, pushing on startElement, popping on endElement. Right now I'm using:&lt;/p&gt;&amp;#xA;&amp;#xA;&lt;pre&gt;&lt;code&gt;public void startElement(String namespaceURI, String elname,&amp;#xA;                         String qName, Attributes atts) throws SAXException {&amp;#xA;    original.append(innerText);&amp;#xA;    original.append(&quot;&amp;lt;&quot;);&amp;#xA;    original.append(elname);&amp;#xA;    original.append(&quot;&amp;gt;&quot;);&amp;#xA;    docStack.push(new StackElement(elname,atts));&amp;#xA;....&amp;#xA;&lt;/code&gt;&lt;/pre&gt;&amp;#xA;&amp;#xA;&lt;p&gt;Unfortunately when it tries to read the atts later, it gives error:&amp;#xA;Caused by: java.lang.IllegalStateException: Attributes can only be used within the scope of startElement().&lt;/p&gt;&amp;#xA;&amp;#xA;&lt;p&gt;Is there any fast, reliable way to store the attributes?&amp;#xA;Also, is there a better way to do this than constructing a new custom object StackElement for each start tag?&lt;/p&gt;&amp;#xA;" stacktrace="Caused by: java.lang.IllegalStateException: Attributes can only be used within the scope of startElement()."/><post answer="" question="&lt;p&gt;I have an TabActivity which hosts several Activitys. Inside 1 Activity I have to set the orientation to &lt;code&gt;landscape&lt;/code&gt; (a camera Activity which wount work in portrait mode on Android 2.1). If I call &lt;code&gt;setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_LANDSCAPE);&lt;/code&gt; inside my Child, nothing seems to happen. I thought that I could try to set the orientation of Activity through its Parent (TabActivity) like this:&lt;/p&gt;&amp;#xA;&amp;#xA;&lt;pre&gt;&lt;code&gt;//DefaultGroup is an FragmentActivity&amp;#xA;public class ChildActivity extends DefaultGroup{&amp;#xA;&amp;#xA;TabActivity mParent;&amp;#xA;int previosOrientation;&amp;#xA;&amp;#xA;&amp;#xA;public void onResume(){&amp;#xA;    super.onResume();&amp;#xA;    if (getParent() instanceof TabActivity){&amp;#xA;        mParent = (TabActivity)getParent();&amp;#xA;        previosOrientation = mParent.getRequestedOrientation();&amp;#xA;        mParent.setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_LANDSCAPE);&amp;#xA;    }&amp;#xA;        //request to DefaultGroup to set CameraFragment as ContentView&amp;#xA;        // 0=id, null= Bundle, false=addToBackStack&amp;#xA;    startFragment(0, null, false);&amp;#xA;}&amp;#xA;&amp;#xA;&amp;#xA;public void onPause(){&amp;#xA;    super.onPause();&amp;#xA;    if (mParent != null){&amp;#xA;        mParent.setRequestedOrientation(previosOrientation);&amp;#xA;    }&amp;#xA;}&amp;#xA;&amp;#xA;@Override&amp;#xA;public DefaultFragment getFragment(int fragment, Bundle args) {&amp;#xA;    return new CameraFragment();&amp;#xA;}&amp;#xA;&amp;#xA;}&amp;#xA;&lt;/code&gt;&lt;/pre&gt;&amp;#xA;&amp;#xA;&lt;p&gt;which works well if the Activity gets created. After I click on another TabButton the orientation is set back to whatever it was before. But if I come back to that Tab I get a forceClose containing this LogCat-Stacktrace:&lt;/p&gt;&amp;#xA;&amp;#xA;&lt;blockquote&gt;&amp;#xA;  &lt;p&gt;01-27 16:19:21.101: E/AndroidRuntime(30134): java.lang.RuntimeException: Unable to resume activity {de.my.namespace.ChildActivity}: java.lang.IllegalStateException: Can not perform this action after onSaveInstanceState&amp;#xA;  01-27 16:19:21.101: E/AndroidRuntime(30134):    at android.app.ActivityThread.performResumeActivity(ActivityThread.java:2444)&amp;#xA;  01-27 16:19:21.101: E/AndroidRuntime(30134):    at android.app.LocalActivityManager.moveToState(LocalActivityManager.java:178)&amp;#xA;  01-27 16:19:21.101: E/AndroidRuntime(30134):    at android.app.LocalActivityManager.startActivity(LocalActivityManager.java:329)&amp;#xA;  01-27 16:19:21.101: E/AndroidRuntime(30134):    at android.widget.TabHost$IntentContentStrategy.getContentView(TabHost.java:682)&amp;#xA;  01-27 16:19:21.101: E/AndroidRuntime(30134):    at android.widget.TabHost.setCurrentTab(TabHost.java:346)&amp;#xA;  01-27 16:19:21.101: E/AndroidRuntime(30134):    at android.widget.TabHost$2.onTabSelectionChanged(TabHost.java:150)&amp;#xA;  01-27 16:19:21.101: E/AndroidRuntime(30134):    at android.widget.TabWidget$TabClickListener.onClick(TabWidget.java:540)&amp;#xA;  01-27 16:19:21.101: E/AndroidRuntime(30134):    at android.view.View.performClick(View.java:3511)&amp;#xA;  01-27 16:19:21.101: E/AndroidRuntime(30134):    at android.view.View$PerformClick.run(View.java:14105)&amp;#xA;  01-27 16:19:21.101: E/AndroidRuntime(30134):    at android.os.Handler.handleCallback(Handler.java:605)&amp;#xA;  01-27 16:19:21.101: E/AndroidRuntime(30134):    at android.os.Handler.dispatchMessage(Handler.java:92)&amp;#xA;  01-27 16:19:21.101: E/AndroidRuntime(30134):    at android.os.Looper.loop(Looper.java:137)&amp;#xA;  01-27 16:19:21.101: E/AndroidRuntime(30134):    at android.app.ActivityThread.main(ActivityThread.java:4424)&amp;#xA;  01-27 16:19:21.101: E/AndroidRuntime(30134):    at java.lang.reflect.Method.invokeNative(Native Method)&amp;#xA;  01-27 16:19:21.101: E/AndroidRuntime(30134):    at java.lang.reflect.Method.invoke(Method.java:511)&amp;#xA;  01-27 16:19:21.101: E/AndroidRuntime(30134):    at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:784)&amp;#xA;  01-27 16:19:21.101: E/AndroidRuntime(30134):    at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:551)&amp;#xA;  01-27 16:19:21.101: E/AndroidRuntime(30134):    at dalvik.system.NativeStart.main(Native Method)&amp;#xA;  01-27 16:19:21.101: E/AndroidRuntime(30134): Caused by: java.lang.IllegalStateException: Can not perform this action after onSaveInstanceState&amp;#xA;  01-27 16:19:21.101: E/AndroidRuntime(30134):    at android.support.v4.app.FragmentManagerImpl.checkStateLoss(FragmentManager.java:1242)&amp;#xA;  01-27 16:19:21.101: E/AndroidRuntime(30134):    at android.support.v4.app.FragmentManagerImpl.enqueueAction(FragmentManager.java:1253)&amp;#xA;  01-27 16:19:21.101: E/AndroidRuntime(30134):    at android.support.v4.app.BackStackRecord.commitInternal(BackStackRecord.java:535)&amp;#xA;  01-27 16:19:21.101: E/AndroidRuntime(30134):    at android.support.v4.app.BackStackRecord.commit(BackStackRecord.java:519)&amp;#xA;  01-27 16:19:21.101: E/AndroidRuntime(30134):    at de.my.namespace.activity.DefaultGroup.addFragment(DefaultGroup.java:162)&amp;#xA;  01-27 16:19:21.101: E/AndroidRuntime(30134):    at de.my.namespace.activity.DefaultGroup.startFragment(DefaultGroup.java:145)&amp;#xA;  01-27 16:19:21.101: E/AndroidRuntime(30134):    at de.my.namespace.activity.ChildaActivity.onResume(AugmentedRealityActivity.java:26)&amp;#xA;  01-27 16:19:21.101: E/AndroidRuntime(30134):    at android.app.Instrumentation.callActivityOnResume(Instrumentation.java:1154)&amp;#xA;  01-27 16:19:21.101: E/AndroidRuntime(30134):    at android.app.Activity.performResume(Activity.java:4539)&amp;#xA;  01-27 16:19:21.101: E/AndroidRuntime(30134):    at android.app.ActivityThread.performResumeActivity(ActivityThread.java:2434)&amp;#xA;  01-27 16:19:21.101: E/AndroidRuntime(30134):    ... 17 more&lt;/p&gt;&amp;#xA;&lt;/blockquote&gt;&amp;#xA;&amp;#xA;&lt;p&gt;so baically my question is: How can I force the orientation of my Child/TabActivity inside one special child while setting these settings back If I leave that special Child?&lt;/p&gt;&amp;#xA;" stacktrace="Caused by: java.lang.IllegalStateException: Can not perform this action after onSaveInstanceState"/><post answer="&lt;p&gt;Each of your Tabs must have a TabListener, for instance:&lt;/p&gt;&amp;#xA;&amp;#xA;&lt;pre&gt;&lt;code&gt;Tab tabRed = actionBar.newTab();&amp;#xA;tabRed.setText(&quot;Red Side&quot;);&amp;#xA;tabRed.setTabListener(this);&amp;#xA;actionBar.addTab(tabRed);&amp;#xA;&amp;#xA;// The same is true for tabBlue&amp;#xA;&lt;/code&gt;&lt;/pre&gt;&amp;#xA;" question="&lt;p&gt;My android app isn't starting for some reason. it's a really basic app. When I run it, it just says that it has to close and I press force close.&lt;/p&gt;&amp;#xA;&amp;#xA;&lt;pre&gt;&lt;code&gt;import com.actionbarsherlock.app.ActionBar.Tab;&amp;#xA;import com.actionbarsherlock.app.ActionBar.TabListener;&amp;#xA;import com.actionbarsherlock.app.*;&amp;#xA;import com.actionbarsherlock.app.SherlockActivity;&amp;#xA;import com.actionbarsherlock.app.ActionBar;&amp;#xA;import com.actionbarsherlock.app.SherlockFragmentActivity;&amp;#xA;&amp;#xA;import android.os.Bundle;&amp;#xA;import android.support.v4.app.FragmentActivity;&amp;#xA;import android.support.v4.app.FragmentTransaction;&amp;#xA;import android.util.Log;&amp;#xA;&amp;#xA;&amp;#xA;public class MainActivity extends SherlockFragmentActivity implements TabListener{&amp;#xA;&amp;#xA;    @Override&amp;#xA;    public void onCreate(Bundle savedInstanceState) {&amp;#xA;        super.onCreate(savedInstanceState);&amp;#xA;        setContentView(R.layout.activity_main);&amp;#xA;&amp;#xA;        final ActionBar actionBar = getSupportActionBar();&amp;#xA;        actionBar.setNavigationMode(ActionBar.NAVIGATION_MODE_TABS);&amp;#xA;&amp;#xA;        Tab tabRed = actionBar.newTab();&amp;#xA;        tabRed.setText(&quot;Red Side&quot;);&amp;#xA;      //  tabRed.setTabListener(new TabListener&amp;lt;TabFragment&amp;gt;(this, &quot;tab1&quot;, TabFragment.class));&amp;#xA;        Tab tabBlue = actionBar.newTab();&amp;#xA;        tabBlue.setText(&quot;Blue Side&quot;);&amp;#xA;       // tabBlue.setTabListener(new TabListener&amp;lt;TabFragment&amp;gt;(this, tabBlue, TabFragment.class));&amp;#xA;&amp;#xA;        actionBar.addTab(tabRed);&amp;#xA;        actionBar.addTab(tabBlue);&amp;#xA;&amp;#xA;&amp;#xA;    }&amp;#xA;&amp;#xA;    @Override&amp;#xA;    public void onTabSelected(Tab tab, FragmentTransaction ft) {&amp;#xA;        Log.d(&quot;Main Activity&quot;, &quot;tab &quot; + String.valueOf(tab.getPosition()) + &quot; clicked&quot;);&amp;#xA;&amp;#xA;    }&amp;#xA;&amp;#xA;    @Override&amp;#xA;    public void onTabUnselected(Tab tab, FragmentTransaction ft) {&amp;#xA;        Log.d(&quot;Main Activity&quot;, &quot;tab &quot; + String.valueOf(tab.getPosition())+ &quot; un-clicked&quot;);&amp;#xA;&amp;#xA;    }&amp;#xA;&amp;#xA;    @Override&amp;#xA;    public void onTabReselected(Tab tab, FragmentTransaction ft) {&amp;#xA;        Log.d(&quot;Main Activity&quot;, &quot;tab &quot; + String.valueOf(tab.getPosition()) + &quot; re-clicked&quot;);&amp;#xA;&amp;#xA;&amp;#xA;    }&amp;#xA;&amp;#xA;&amp;#xA;&amp;#xA;}&amp;#xA;&lt;/code&gt;&lt;/pre&gt;&amp;#xA;&amp;#xA;&lt;p&gt;This is my &lt;code&gt;activity_main.xml&lt;/code&gt;, which just has text in it. Do I have to set up the action bar in the xml as well?&lt;/p&gt;&amp;#xA;&amp;#xA;&lt;pre&gt;&lt;code&gt;&amp;lt;RelativeLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&amp;#xA;    xmlns:tools=&quot;http://schemas.android.com/tools&quot;&amp;#xA;    android:layout_width=&quot;match_parent&quot;&amp;#xA;    android:layout_height=&quot;match_parent&quot;&amp;#xA;    tools:context=&quot;.MainActivity&quot; &amp;gt;&amp;#xA;&amp;#xA;&amp;#xA;&amp;#xA;     &amp;lt;TextView&amp;#xA;        android:id=&quot;@+id/textView1&quot;&amp;#xA;        android:layout_width=&quot;wrap_content&quot;&amp;#xA;        android:layout_height=&quot;wrap_content&quot;&amp;#xA;        android:layout_centerHorizontal=&quot;true&quot;&amp;#xA;        android:layout_centerVertical=&quot;true&quot;&amp;#xA;        android:text=&quot;@string/hello_world&quot; /&amp;gt;&amp;#xA;&amp;#xA;&amp;lt;/RelativeLayout&amp;gt;&amp;#xA;&lt;/code&gt;&lt;/pre&gt;&amp;#xA;&amp;#xA;&lt;p&gt;The logcat&lt;/p&gt;&amp;#xA;&amp;#xA;&lt;pre&gt;&lt;code&gt;12-22 00:19:37.846: E/AndroidRuntime(1833): FATAL EXCEPTION: main&amp;#xA;12-22 00:19:37.846: E/AndroidRuntime(1833): java.lang.RuntimeException: Unable to start activity ComponentInfo{org.say.upscorer/org.say.upscorer.MainActivity}: java.lang.IllegalStateException: Action Bar Tab must have a Callback&amp;#xA;12-22 00:19:37.846: E/AndroidRuntime(1833):     at android.app.ActivityThread.performLaunchActivity(ActivityThread.java:2663)&amp;#xA;12-22 00:19:37.846: E/AndroidRuntime(1833):     at android.app.ActivityThread.handleLaunchActivity(ActivityThread.java:2679)&amp;#xA;12-22 00:19:37.846: E/AndroidRuntime(1833):     at android.app.ActivityThread.access$2300(ActivityThread.java:125)&amp;#xA;12-22 00:19:37.846: E/AndroidRuntime(1833):     at android.app.ActivityThread$H.handleMessage(ActivityThread.java:2033)&amp;#xA;12-22 00:19:37.846: E/AndroidRuntime(1833):     at android.os.Handler.dispatchMessage(Handler.java:99)&amp;#xA;12-22 00:19:37.846: E/AndroidRuntime(1833):     at android.os.Looper.loop(Looper.java:123)&amp;#xA;12-22 00:19:37.846: E/AndroidRuntime(1833):     at android.app.ActivityThread.main(ActivityThread.java:4627)&amp;#xA;12-22 00:19:37.846: E/AndroidRuntime(1833):     at java.lang.reflect.Method.invokeNative(Native Method)&amp;#xA;12-22 00:19:37.846: E/AndroidRuntime(1833):     at java.lang.reflect.Method.invoke(Method.java:521)&amp;#xA;12-22 00:19:37.846: E/AndroidRuntime(1833):     at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:868)&amp;#xA;12-22 00:19:37.846: E/AndroidRuntime(1833):     at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:626)&amp;#xA;12-22 00:19:37.846: E/AndroidRuntime(1833):     at dalvik.system.NativeStart.main(Native Method)&amp;#xA;12-22 00:19:37.846: E/AndroidRuntime(1833): Caused by: java.lang.IllegalStateException: Action Bar Tab must have a Callback&amp;#xA;12-22 00:19:37.846: E/AndroidRuntime(1833):     at com.actionbarsherlock.internal.app.ActionBarImpl.configureTab(ActionBarImpl.java:424)&amp;#xA;12-22 00:19:37.846: E/AndroidRuntime(1833):     at com.actionbarsherlock.internal.app.ActionBarImpl.addTab(ActionBarImpl.java:450)&amp;#xA;12-22 00:19:37.846: E/AndroidRuntime(1833):     at com.actionbarsherlock.internal.app.ActionBarImpl.addTab(ActionBarImpl.java:438)&amp;#xA;12-22 00:19:37.846: E/AndroidRuntime(1833):     at org.say.upscorer.MainActivity.onCreate(MainActivity.java:33)&amp;#xA;12-22 00:19:37.846: E/AndroidRuntime(1833):     at android.app.Instrumentation.callActivityOnCreate(Instrumentation.java:1047)&amp;#xA;12-22 00:19:37.846: E/AndroidRuntime(1833):     at android.app.ActivityThread.performLaunchActivity(ActivityThread.java:2627)&amp;#xA;12-22 00:19:37.846: E/AndroidRuntime(1833):     ... 11 more&amp;#xA;&lt;/code&gt;&lt;/pre&gt;&amp;#xA;" stacktrace="Caused by: java.lang.IllegalStateException: Action Bar Tab must have a Callback"/><post answer="" question="&lt;p&gt;I must put my own Executor to work with Spring @Async annotation. For this, I wrote the class along the lines&lt;/p&gt;&amp;#xA;&amp;#xA;&lt;pre&gt;&lt;code&gt;@Configuration&amp;#xA;@EnableAsync&amp;#xA;public class ConnectedThreads implements AsyncConfigurer {&amp;#xA;&amp;#xA;  @Override&amp;#xA;  public Executor getAsyncExecutor() {&amp;#xA;    return ...&amp;#xA;&lt;/code&gt;&lt;/pre&gt;&amp;#xA;&amp;#xA;&lt;p&gt;When I try to run the Spring Boot application with this class, the applications crashes with  &lt;/p&gt;&amp;#xA;&amp;#xA;&lt;pre&gt;&lt;code&gt;Caused by: java.lang.IllegalStateException: Only one AsyncConfigurer may exist&amp;#xA;    at org.springframework.scheduling.annotation.AbstractAsyncConfiguration.setConfigurers(AbstractAsyncConfiguration.java:68)&amp;#xA;&lt;/code&gt;&lt;/pre&gt;&amp;#xA;&amp;#xA;&lt;p&gt;There is no another configurer in the project. It is a very small project, and I have full control over it. I myself suspect that the custom configurer may simply conflict with the default configurer.&lt;/p&gt;&amp;#xA;&amp;#xA;&lt;p&gt;Is there any possibility to say to Spring that THIS is the configurer I need and it should not look for any other?&lt;/p&gt;&amp;#xA;" stacktrace="Caused by: java.lang.IllegalStateException: Only one AsyncConfigurer may exist&#10;    at org.springframework.scheduling.annotation.AbstractAsyncConfiguration.setConfigurers(AbstractAsyncConfiguration.java:68)"/><post answer="&lt;p&gt;Using &lt;code&gt;Theme.AppCompat.Light&lt;/code&gt; tells Android that you want the framework to provide an ActionBar for you. However, you are creating your own ActionBar (a &lt;code&gt;Toolbar&lt;/code&gt;), so you are giving the framework mixed signals as to where you want the ActionBar to come from.&lt;/p&gt;&amp;#xA;&amp;#xA;&lt;p&gt;Since you are using a Toolbar, you want &lt;code&gt;Theme.AppCompat.Light.NoActionBar&lt;/code&gt;.&lt;/p&gt;&amp;#xA;&amp;#xA;&lt;p&gt;The next step is to make sure your Toolbar is styled correctly, which seems to be where you are running into issues. To style your Toolbar like an ActionBar using the colors you defined for your theme, you need to provide a theme like so:&lt;/p&gt;&amp;#xA;&amp;#xA;&lt;pre&gt;&lt;code&gt;&amp;lt;android.support.v7.widget.Toolbar&amp;#xA;    android:layout_height=&quot;wrap_content&quot;&amp;#xA;    android:layout_width=&quot;match_parent&quot;&amp;#xA;    android:minHeight=&quot;?attr/actionBarSize&quot;&amp;#xA;    app:theme=&quot;@style/ThemeOverlay.AppCompat.ActionBar&quot; /&amp;gt;&amp;#xA;&lt;/code&gt;&lt;/pre&gt;&amp;#xA;&amp;#xA;&lt;p&gt;See the &quot;styling&quot; section for the Toolbar widget on &lt;a href=&quot;http://android-developers.blogspot.com/2014/10/appcompat-v21-material-design-for-pre.html&quot;&gt;this Android Developers blog post&lt;/a&gt; for more information.&lt;/p&gt;&amp;#xA;" question="&lt;p&gt;I'm trying to build my app but without success.. I tried several way but nothing was worked. The exception is:&lt;/p&gt;&amp;#xA;&amp;#xA;&lt;pre&gt;&lt;code&gt;Caused by: java.lang.IllegalStateException: This Activity already has an action bar supplied by the window decor. Do not request Window.FEATURE_ACTION_BAR and set windowActionBar to false in your theme to use a Toolbar instead.&amp;#xA;&lt;/code&gt;&lt;/pre&gt;&amp;#xA;&amp;#xA;&lt;p&gt;My style.xml is:&lt;/p&gt;&amp;#xA;&amp;#xA;&lt;pre&gt;&lt;code&gt;&amp;lt;resources&amp;gt;&amp;#xA;&amp;#xA;    &amp;lt;style name=&quot;AppTheme&quot; parent=&quot;Theme.AppCompat.Light&quot;&amp;gt;&amp;#xA;&amp;#xA;        &amp;lt;!-- theme customizations --&amp;gt;&amp;#xA;&amp;#xA;        &amp;lt;item name=&quot;colorPrimary&quot;&amp;gt;@color/colorPrimary&amp;lt;/item&amp;gt;&amp;#xA;        &amp;lt;item name=&quot;colorPrimaryDark&quot;&amp;gt;@color/colorPrimaryDark&amp;lt;/item&amp;gt;&amp;#xA;        &amp;lt;item name=&quot;colorAccent&quot;&amp;gt;@color/colorAccent&amp;lt;/item&amp;gt;&amp;#xA;        &amp;lt;item name=&quot;android:windowNoTitle&quot;&amp;gt;true&amp;lt;/item&amp;gt;&amp;#xA;        &amp;lt;item name=&quot;android:windowActionBar&quot;&amp;gt;false&amp;lt;/item&amp;gt;&amp;#xA;&amp;#xA;        &amp;lt;item name=&quot;android:textColorPrimary&quot;&amp;gt;@color/ldrawer_color&amp;lt;/item&amp;gt;&amp;#xA;        &amp;lt;item name=&quot;actionMenuTextColor&quot;&amp;gt;@color/ldrawer_color&amp;lt;/item&amp;gt;&amp;#xA;        &amp;lt;item name=&quot;android:textColorSecondary&quot;&amp;gt;@color/ldrawer_color&amp;lt;/item&amp;gt;&amp;#xA;    &amp;lt;/style&amp;gt;&amp;#xA;&amp;#xA;&amp;lt;/resources&amp;gt;&amp;#xA;&lt;/code&gt;&lt;/pre&gt;&amp;#xA;&amp;#xA;&lt;p&gt;and as you can see i have declared&lt;/p&gt;&amp;#xA;&amp;#xA;&lt;pre&gt;&lt;code&gt;&amp;lt;item name=&quot;android:windowNoTitle&quot;&amp;gt;true&amp;lt;/item&amp;gt;&amp;#xA;&amp;lt;item name=&quot;android:windowActionBar&quot;&amp;gt;false&amp;lt;/item&amp;gt;&amp;#xA;&lt;/code&gt;&lt;/pre&gt;&amp;#xA;&amp;#xA;&lt;p&gt;This is my manifest.xml&lt;/p&gt;&amp;#xA;&amp;#xA;&lt;pre&gt;&lt;code&gt; &amp;lt;application&amp;#xA;        android:allowBackup=&quot;true&quot;&amp;#xA;        tools:replace=&quot;android:icon&quot;&amp;#xA;        android:icon=&quot;@mipmap/ic_launcher&quot;&amp;#xA;        android:label=&quot;@string/app_name&quot;&amp;#xA;        android:theme=&quot;@style/AppTheme&quot; &amp;gt;&amp;#xA;        &amp;lt;activity&amp;#xA;            android:name=&quot;.MainActivity&quot;&amp;#xA;            android:label=&quot;@string/app_name&quot; &amp;gt;&amp;#xA;            &amp;lt;intent-filter&amp;gt;&amp;#xA;                &amp;lt;action android:name=&quot;android.intent.action.MAIN&quot; /&amp;gt;&amp;#xA;&amp;#xA;                &amp;lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&amp;gt;&amp;#xA;            &amp;lt;/intent-filter&amp;gt;&amp;#xA;        &amp;lt;/activity&amp;gt;&amp;#xA;    &amp;lt;/application&amp;gt;&amp;#xA;&lt;/code&gt;&lt;/pre&gt;&amp;#xA;&amp;#xA;&lt;p&gt;and my &lt;code&gt;BaseActivity&lt;/code&gt; that i use to extend other activities&lt;/p&gt;&amp;#xA;&amp;#xA;&lt;pre&gt;&lt;code&gt;import android.os.Bundle;&amp;#xA;import android.support.v7.app.AppCompatActivity;&amp;#xA;import android.support.v7.widget.Toolbar;&amp;#xA;&amp;#xA;public abstract class BaseActivity extends AppCompatActivity {&amp;#xA;&amp;#xA;    public Toolbar toolbar;&amp;#xA;&amp;#xA;    @Override&amp;#xA;    protected void onCreate(Bundle savedInstanceState) {&amp;#xA;        super.onCreate(savedInstanceState);&amp;#xA;        setContentView(getLayoutResource());&amp;#xA;        toolbar = (Toolbar) findViewById(R.id.toolbar);&amp;#xA;        if (toolbar != null) {&amp;#xA;            setSupportActionBar(toolbar);&amp;#xA;            getSupportActionBar().setTitle(BaseActivity.this.getResources().getString(R.string.app_name));&amp;#xA;            //getSupportActionBar().setDisplayHomeAsUpEnabled(true);&amp;#xA;        }&amp;#xA;    }&amp;#xA;&amp;#xA;    protected abstract int getLayoutResource();&amp;#xA;&amp;#xA;    protected void setActionBarIcon(int iconRes) {&amp;#xA;        toolbar.setNavigationIcon(iconRes);&amp;#xA;    }&amp;#xA;&amp;#xA;}&amp;#xA;&lt;/code&gt;&lt;/pre&gt;&amp;#xA;&amp;#xA;&lt;p&gt;I don't know why it crashes..The only way to start the application without crash is set the parent on the style.xml in &lt;code&gt;Theme.AppCompat.Light.NoActionBar&lt;/code&gt; but in this way the status bar is transparent and not colored...&lt;/p&gt;&amp;#xA;" stacktrace="Caused by: java.lang.IllegalStateException: This Activity already has an action bar supplied by the window decor. Do not request Window.FEATURE_ACTION_BAR and set windowActionBar to false in your theme to use a Toolbar instead."/><post answer="" question="&lt;p&gt;I try to get current location and user activity, following the guide from &amp;#xA;&lt;a href=&quot;http://j.mp/io13-location&quot; rel=&quot;nofollow&quot;&gt;http://j.mp/io13-location&lt;/a&gt; the &quot;checkpoint_final&quot;  &lt;/p&gt;&amp;#xA;&amp;#xA;&lt;p&gt;but i got those error when i run the program.&lt;/p&gt;&amp;#xA;&amp;#xA;&lt;p&gt;my logCat:&lt;/p&gt;&amp;#xA;&amp;#xA;&lt;pre&gt;&lt;code&gt;02-21 18:12:38.439: E/AndroidRuntime(3798): FATAL EXCEPTION: main&amp;#xA;02-21 18:12:38.439: E/AndroidRuntime(3798): Process:   com.android.google.codelab.location, PID: 3798&amp;#xA;02-21 18:12:38.439: E/AndroidRuntime(3798): java.lang.RuntimeException: Unable to resume activity {com.android.google.codelab.location/com.android.google.codelab.location.LocationActivity}: java.lang.IllegalStateException: Not connected. Call connect() and wait for onConnected() to be called.&amp;#xA;02-21 18:12:38.439: E/AndroidRuntime(3798):     at android.app.ActivityThread.performResumeActivity(ActivityThread.java:2788)&amp;#xA;02-21 18:12:38.439: E/AndroidRuntime(3798):     at android.app.ActivityThread.handleResumeActivity(ActivityThread.java:2817)&amp;#xA;02-21 18:12:38.439: E/AndroidRuntime(3798):     at android.app.ActivityThread.handleLaunchActivity(ActivityThread.java:2250)&amp;#xA;02-21 18:12:38.439: E/AndroidRuntime(3798):     at android.app.ActivityThread.access$800(ActivityThread.java:135)&amp;#xA;02-21 18:12:38.439: E/AndroidRuntime(3798):     at android.app.ActivityThread$H.handleMessage(ActivityThread.java:1196)&amp;#xA;02-21 18:12:38.439: E/AndroidRuntime(3798):     at android.os.Handler.dispatchMessage(Handler.java:102)&amp;#xA;02-21 18:12:38.439: E/AndroidRuntime(3798):     at android.os.Looper.loop(Looper.java:136)&amp;#xA;02-21 18:12:38.439: E/AndroidRuntime(3798):     at android.app.ActivityThread.main(ActivityThread.java:5017)&amp;#xA;02-21 18:12:38.439: E/AndroidRuntime(3798):     at java.lang.reflect.Method.invokeNative(Native Method)&amp;#xA;02-21 18:12:38.439: E/AndroidRuntime(3798):     at java.lang.reflect.Method.invoke(Method.java:515)&amp;#xA;02-21 18:12:38.439: E/AndroidRuntime(3798):     at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:779)&amp;#xA;02-21 18:12:38.439: E/AndroidRuntime(3798):     at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:595)&amp;#xA;02-21 18:12:38.439: E/AndroidRuntime(3798):     at dalvik.system.NativeStart.main(Native Method)&amp;#xA;02-21 18:12:38.439: E/AndroidRuntime(3798): Caused by: java.lang.IllegalStateException: Not connected. Call connect() and wait for onConnected() to be called.&amp;#xA;02-21 18:12:38.439: E/AndroidRuntime(3798):     at com.google.android.gms.internal.dk.bB(Unknown Source)&amp;#xA;02-21 18:12:38.439: E/AndroidRuntime(3798):     at com.google.android.gms.internal.fm.a(Unknown Source)&amp;#xA;02-21 18:12:38.439: E/AndroidRuntime(3798):     at com.google.android.gms.internal.fm$c.bB(Unknown Source)&amp;#xA;02-21 18:12:38.439: E/AndroidRuntime(3798):     at com.google.android.gms.internal.fl.requestLocationUpdates(Unknown Source)&amp;#xA;02-21 18:12:38.439: E/AndroidRuntime(3798):     at com.google.android.gms.internal.fm.requestLocationUpdates(Unknown Source)&amp;#xA;02-21 18:12:38.439: E/AndroidRuntime(3798):     at com.google.android.gms.internal.fm.requestLocationUpdates(Unknown Source)&amp;#xA;02-21 18:12:38.439: E/AndroidRuntime(3798):     at com.google.android.gms.location.LocationClient.requestLocationUpdates(Unknown Source)&amp;#xA;02-21 18:12:38.439: E/AndroidRuntime(3798):     at com.android.google.codelab.location.LocationActivity.restartLocationClient(LocationActivity.java:248)&amp;#xA;02-21 18:12:38.439: E/AndroidRuntime(3798):     at com.android.google.codelab.location.LocationActivity.onResume(LocationActivity.java:197)&amp;#xA;02-21 18:12:38.439: E/AndroidRuntime(3798):     at android.app.Instrumentation.callActivityOnResume(Instrumentation.java:1192)&amp;#xA;02-21 18:12:38.439: E/AndroidRuntime(3798):     at android.app.Activity.performResume(Activity.java:5310)&amp;#xA;02-21 18:12:38.439: E/AndroidRuntime(3798):     at android.app.ActivityThread.performResumeActivity(ActivityThread.java:2778)&amp;#xA;02-21 18:12:38.439: E/AndroidRuntime(3798):     ... 12 more&amp;#xA;&lt;/code&gt;&lt;/pre&gt;&amp;#xA;&amp;#xA;&lt;p&gt;my Code&lt;/p&gt;&amp;#xA;&amp;#xA;&lt;pre&gt;&lt;code&gt;public class LocationActivity extends FragmentActivity {&amp;#xA;public static String TAG = &quot;LocationActivity&quot;;&amp;#xA;public static boolean isAppForeground = false;&amp;#xA;private static final int ERROR_DIALOG_ON_CREATE_REQUEST_CODE = 4055;&amp;#xA;private static final int ERROR_DIALOG_ON_RESUME_REQUEST_CODE = 4056;&amp;#xA;&amp;#xA;// Shared variables&amp;#xA;private GoogleMap mMap;&amp;#xA;private Dialog errorDialog;&amp;#xA;&amp;#xA;// Location Request variables&amp;#xA;private LocationClient mLocationClient;&amp;#xA;private TextView mLocationStatus;&amp;#xA;private LocationCallback mLocationCallback = new LocationCallback();&amp;#xA;private Location mLastLocation;&amp;#xA;private static final int LOCATION_UPDATES_INTERVAL = 10000; // Setting 10 sec interval for location updates&amp;#xA;&amp;#xA;// Activity Recognition variables&amp;#xA;private ActivityRecognitionClient mActivityRecognitionClient;&amp;#xA;private ActivityRecognitionCallback mActivityRecognitionCallback = new ActivityRecognitionCallback();&amp;#xA;public static final String ACTION_ACTIVITY_RECOGNITION = &amp;#xA;        &quot;com.android.google.codelab.location.LocationActivity.ACTIVITY_RECOGNITION&quot;;&amp;#xA;private static final int ACTIVITY_UPDATES_INTERVAL = 4000;&amp;#xA;private PendingIntent mActivityRecognitionPendingIntent;&amp;#xA;private Switch mSwitch;&amp;#xA;private ActivityRecognitionIntentReceiver mActivityRecognitionIntentReceiver;&amp;#xA;&amp;#xA;// Geo Fencing variables&amp;#xA;private GeoFenceCallback mGeoFenceCallback = new GeoFenceCallback();&amp;#xA;private int id = 0;&amp;#xA;private static final float GEOFENCE_RADIUS = 100;&amp;#xA;private HashMap&amp;lt;String, Circle&amp;gt; mGeoFences;&amp;#xA;private HashMap&amp;lt;String, Circle&amp;gt; mTriggeringFences;&amp;#xA;public static final String ACTION_GEOFENCE =&amp;#xA;        &quot;com.android.google.codelab.location.LocationActivity.GEOFENCE&quot;;&amp;#xA;private TextView mGeoFenceStatus;&amp;#xA;&amp;#xA;/** Called when the activity is first created. */&amp;#xA;@Override&amp;#xA;public void onCreate(Bundle savedInstanceState)&amp;#xA;{&amp;#xA;    super.onCreate(savedInstanceState);&amp;#xA;    setContentView(R.layout.main);&amp;#xA;&amp;#xA;    checkGooglePlayServiceAvailability(ERROR_DIALOG_ON_CREATE_REQUEST_CODE);&amp;#xA;}&amp;#xA;&amp;#xA;private void init() {&amp;#xA;    // Initialize map&amp;#xA;    if (mMap == null) {&amp;#xA;        FragmentManager myFragmentManager = getSupportFragmentManager();&amp;#xA;        SupportMapFragment myMapFragment =&amp;#xA;                (SupportMapFragment) myFragmentManager.findFragmentById(R.id.map);&amp;#xA;        mMap = myMapFragment.getMap();&amp;#xA;    }&amp;#xA;&amp;#xA;    // Initialize Location Client&amp;#xA;    mLocationStatus = (TextView) findViewById(R.id.location_status);&amp;#xA;&amp;#xA;    if (mLocationClient == null) {&amp;#xA;        mLocationClient = new LocationClient(this, mLocationCallback, mLocationCallback);&amp;#xA;        Log.v(LocationActivity.TAG, &quot;Location Client connect&quot;);&amp;#xA;        if (!(mLocationClient.isConnected() || mLocationClient.isConnecting())) {&amp;#xA;            mLocationClient.connect();&amp;#xA;        }&amp;#xA;    }&amp;#xA;&amp;#xA;    // Initialize Action Recognition&amp;#xA;    if (mActivityRecognitionClient == null) {&amp;#xA;        mActivityRecognitionClient =&amp;#xA;                new ActivityRecognitionClient(this, &amp;#xA;                        mActivityRecognitionCallback, mActivityRecognitionCallback);&amp;#xA;    }&amp;#xA;&amp;#xA;    mSwitch = (Switch) findViewById(R.id.swtich);&amp;#xA;    mSwitch.setOnCheckedChangeListener(new OnCheckedChangeListener() {&amp;#xA;        @Override&amp;#xA;        public void onCheckedChanged(CompoundButton buttonView, boolean isChecked) {&amp;#xA;            if (isChecked) {&amp;#xA;                startActivityDetection(buttonView);&amp;#xA;            } else {&amp;#xA;                stopActivityDetection(buttonView);&amp;#xA;            }&amp;#xA;        }&amp;#xA;    });&amp;#xA;&amp;#xA;    if (mActivityRecognitionIntentReceiver == null) {&amp;#xA;        mActivityRecognitionIntentReceiver = new ActivityRecognitionIntentReceiver();&amp;#xA;        registerReceiver(mActivityRecognitionIntentReceiver,&amp;#xA;                new IntentFilter(LocationActivity.ACTION_ACTIVITY_RECOGNITION));&amp;#xA;    }&amp;#xA;&amp;#xA;    // Initialize Geo Fencing&amp;#xA;    mGeoFenceStatus = (TextView) findViewById(R.id.geo_fence_status);&amp;#xA;&amp;#xA;    if (mGeoFences == null) {&amp;#xA;        mGeoFences = new HashMap&amp;lt;String, Circle&amp;gt;();&amp;#xA;    }&amp;#xA;&amp;#xA;    if (mTriggeringFences == null) {&amp;#xA;        mTriggeringFences = new  HashMap&amp;lt;String, Circle&amp;gt;();&amp;#xA;    }&amp;#xA;&amp;#xA;    // Setup map to allow adding Geo Fences&amp;#xA;    mMap.getUiSettings().setAllGesturesEnabled(true);&amp;#xA;    mMap.setOnMapLongClickListener(mGeoFenceCallback);&amp;#xA;}&amp;#xA;&amp;#xA;@Override&amp;#xA;public void onPause() {&amp;#xA;    super.onPause();&amp;#xA;&amp;#xA;    // Indicate the application is in background&amp;#xA;    isAppForeground = false;&amp;#xA;&amp;#xA;    if (mLocationClient.isConnected()) {&amp;#xA;        mLocationClient.removeLocationUpdates(mLocationCallback);&amp;#xA;        mLocationClient.disconnect();&amp;#xA;    }&amp;#xA;}&amp;#xA;&amp;#xA;@Override&amp;#xA;public void onResume() {&amp;#xA;    super.onResume();&amp;#xA;&amp;#xA;    // Indicate the application is in foreground&amp;#xA;    isAppForeground = true;&amp;#xA;&amp;#xA;    checkGooglePlayServiceAvailability(ERROR_DIALOG_ON_RESUME_REQUEST_CODE);&amp;#xA;&amp;#xA;    restartLocationClient();&amp;#xA;}&amp;#xA;&amp;#xA;@Override&amp;#xA;public void onDestroy() {&amp;#xA;    super.onDestroy();&amp;#xA;    unregisterReceiver(mActivityRecognitionIntentReceiver);&amp;#xA;    mActivityRecognitionIntentReceiver = null;&amp;#xA;}&amp;#xA;&amp;#xA;private void checkGooglePlayServiceAvailability(int requestCode) {&amp;#xA;    // Query for the status of Google Play services on the device&amp;#xA;    int statusCode = GooglePlayServicesUtil&amp;#xA;            .isGooglePlayServicesAvailable(getBaseContext());&amp;#xA;&amp;#xA;    if (statusCode == ConnectionResult.SUCCESS) {&amp;#xA;        init();&amp;#xA;    } else {&amp;#xA;        if (GooglePlayServicesUtil.isUserRecoverableError(statusCode)) {&amp;#xA;            errorDialog = GooglePlayServicesUtil.getErrorDialog(statusCode,&amp;#xA;                    this, requestCode);&amp;#xA;            errorDialog.show();&amp;#xA;        } else {&amp;#xA;            // Handle unrecoverable error&amp;#xA;        }&amp;#xA;    }&amp;#xA;}&amp;#xA;&amp;#xA;@Override&amp;#xA;protected void onActivityResult(int requestCode, int resultCode, Intent data) {&amp;#xA;    super.onActivityResult(requestCode, resultCode, data);&amp;#xA;    if (resultCode == RESULT_OK) {&amp;#xA;        switch (requestCode) {&amp;#xA;        case ERROR_DIALOG_ON_CREATE_REQUEST_CODE:&amp;#xA;            init();&amp;#xA;            break;&amp;#xA;        case ERROR_DIALOG_ON_RESUME_REQUEST_CODE:&amp;#xA;            restartLocationClient();&amp;#xA;            break;&amp;#xA;        }&amp;#xA;    }&amp;#xA;}&amp;#xA;&amp;#xA;private void restartLocationClient() {&amp;#xA;    if (!(mLocationClient.isConnected() || mLocationClient.isConnecting())) {&amp;#xA;        mLocationClient.connect(); // Somehow it becomes connected here&amp;#xA;        return;&amp;#xA;    }&amp;#xA;    LocationRequest request = LocationRequest.create();&amp;#xA;    request.setInterval(LOCATION_UPDATES_INTERVAL);&amp;#xA;    request.setPriority(LocationRequest.PRIORITY_HIGH_ACCURACY);&amp;#xA;    mLocationClient.requestLocationUpdates(request, mLocationCallback);&amp;#xA;}&amp;#xA;&amp;#xA;@Override&amp;#xA;public void onConfigurationChanged(Configuration newConfig) {&amp;#xA;    super.onConfigurationChanged(newConfig);&amp;#xA;}&amp;#xA;&amp;#xA;@Override&amp;#xA;public boolean onCreateOptionsMenu(Menu menu) {&amp;#xA;    MenuItem menuItem = menu.add(R.string.clear_map);&amp;#xA;    menuItem.setShowAsAction(MenuItem.SHOW_AS_ACTION_ALWAYS);&amp;#xA;    menuItem.setOnMenuItemClickListener(new OnMenuItemClickListener() {&amp;#xA;        @Override&amp;#xA;        public boolean onMenuItemClick(MenuItem item) {&amp;#xA;            clearMap();&amp;#xA;            return true;&amp;#xA;        }&amp;#xA;    });&amp;#xA;    return true;&amp;#xA;}&amp;#xA;&amp;#xA;public void clearMap() {&amp;#xA;    mMap.clear();&amp;#xA;    mLastLocation = null;&amp;#xA;    mGeoFenceCallback.removeGeoFences();&amp;#xA;}&amp;#xA;&amp;#xA;private class LocationCallback implements ConnectionCallbacks, OnConnectionFailedListener,&amp;#xA;    LocationListener {&amp;#xA;&amp;#xA;    @Override&amp;#xA;    public void onConnected(Bundle connectionHint) {&amp;#xA;        Log.v(LocationActivity.TAG, &quot;Location Client connected&quot;);&amp;#xA;&amp;#xA;        // Display last location&amp;#xA;        Location location = mLocationClient.getLastLocation();&amp;#xA;        if (location != null) {&amp;#xA;            handleLocation(location);&amp;#xA;        }&amp;#xA;&amp;#xA;        // Request for location updates&amp;#xA;        LocationRequest request = LocationRequest.create();&amp;#xA;        request.setInterval(LOCATION_UPDATES_INTERVAL);&amp;#xA;        request.setPriority(LocationRequest.PRIORITY_HIGH_ACCURACY);&amp;#xA;        mLocationClient.requestLocationUpdates(request, mLocationCallback);&amp;#xA;    }&amp;#xA;&amp;#xA;    @Override&amp;#xA;    public void onDisconnected() {&amp;#xA;        Log.v(LocationActivity.TAG, &quot;Location Client disconnected by the system&quot;);&amp;#xA;    }&amp;#xA;&amp;#xA;    @Override&amp;#xA;    public void onConnectionFailed(ConnectionResult result) {&amp;#xA;        Log.v(LocationActivity.TAG, &quot;Location Client connection failed&quot;);&amp;#xA;    }&amp;#xA;&amp;#xA;    @Override&amp;#xA;    public void onLocationChanged(Location location) {&amp;#xA;        if (location == null) {&amp;#xA;            Log.v(LocationActivity.TAG, &quot;onLocationChanged: location == null&quot;);&amp;#xA;            return;&amp;#xA;        }&amp;#xA;        // Add a marker iff location has changed.&amp;#xA;        if (mLastLocation != null &amp;amp;&amp;amp;&amp;#xA;            mLastLocation.getLatitude() == location.getLatitude() &amp;amp;&amp;amp;&amp;#xA;            mLastLocation.getLongitude() == location.getLongitude()) {&amp;#xA;            return;&amp;#xA;        }&amp;#xA;&amp;#xA;        handleLocation(location);&amp;#xA;    }&amp;#xA;&amp;#xA;    private void handleLocation(Location location) {&amp;#xA;        // Update the mLocationStatus with the lat/lng of the location&amp;#xA;        Log.v(LocationActivity.TAG, &quot;LocationChanged == @&quot; +&amp;#xA;                location.getLatitude() + &quot;,&quot; + location.getLongitude());&amp;#xA;        mLocationStatus.setText(&quot;Location changed @&quot; + location.getLatitude() + &quot;,&quot; +&amp;#xA;                location.getLongitude());&amp;#xA;&amp;#xA;        // Add a marker of that location to the map&amp;#xA;        LatLng latlongzoom = new LatLng(location.getLatitude(),&amp;#xA;                location.getLongitude());&amp;#xA;        String snippet = location.getLatitude() + &quot;,&quot; + location.getLongitude();&amp;#xA;        Marker marker = mMap.addMarker(&amp;#xA;                new MarkerOptions().position(latlongzoom));&amp;#xA;        marker.setSnippet(snippet);&amp;#xA;        marker.setTitle(snippet);&amp;#xA;&amp;#xA;        // Center the map to the first marker &amp;#xA;        if (mLastLocation == null) {&amp;#xA;            mMap.moveCamera(CameraUpdateFactory.&amp;#xA;                    newCameraPosition(CameraPosition.fromLatLngZoom(&amp;#xA;                    new LatLng(location.getLatitude(), location.getLongitude()),&amp;#xA;                    (float) 16.0)));&amp;#xA;        }&amp;#xA;        mLastLocation = location;&amp;#xA;    }&amp;#xA;};&amp;#xA;&amp;#xA;public void startActivityDetection(View v) {&amp;#xA;    if (!mActivityRecognitionClient.isConnected()) {&amp;#xA;        mActivityRecognitionClient.connect();&amp;#xA;    }&amp;#xA;}&amp;#xA;&amp;#xA;public void stopActivityDetection(View v) {&amp;#xA;    if (mActivityRecognitionClient.isConnected()) {&amp;#xA;        mActivityRecognitionClient.removeActivityUpdates(mActivityRecognitionPendingIntent);&amp;#xA;        mActivityRecognitionClient.disconnect();&amp;#xA;    }&amp;#xA;}&amp;#xA;&amp;#xA;private class ActivityRecognitionCallback implements ConnectionCallbacks, OnConnectionFailedListener {&amp;#xA;    @Override&amp;#xA;    public void onConnected(Bundle connectionHint) {&amp;#xA;        Log.v(LocationActivity.TAG, &quot;Activity Recognition Client connected&quot;);&amp;#xA;&amp;#xA;        // Request activity updates&amp;#xA;        Intent intent = new Intent(LocationActivity.this,&amp;#xA;                ActivityRecognitionIntentService.class);&amp;#xA;        intent.setAction(LocationActivity.ACTION_ACTIVITY_RECOGNITION);&amp;#xA;        mActivityRecognitionPendingIntent = PendingIntent.getService(LocationActivity.this, 0, intent,&amp;#xA;                PendingIntent.FLAG_UPDATE_CURRENT);&amp;#xA;        mActivityRecognitionClient.requestActivityUpdates(ACTIVITY_UPDATES_INTERVAL,&amp;#xA;                mActivityRecognitionPendingIntent);&amp;#xA;    }&amp;#xA;&amp;#xA;    @Override&amp;#xA;    public void onDisconnected() {&amp;#xA;        Log.v(LocationActivity.TAG, &quot;Activity Recognition Client disconnected by the system&quot;);&amp;#xA;    }&amp;#xA;&amp;#xA;    @Override&amp;#xA;    public void onConnectionFailed(ConnectionResult result) {&amp;#xA;        Log.v(LocationActivity.TAG,&amp;#xA;                &quot;Activity Recognition Client connection failed &quot; + result.getErrorCode());&amp;#xA;    }&amp;#xA;};&amp;#xA;&amp;#xA;private class GeoFenceCallback implements OnMapLongClickListener,&amp;#xA;    OnAddGeofencesResultListener, OnRemoveGeofencesResultListener {&amp;#xA;&amp;#xA;    @Override&amp;#xA;    public void onMapLongClick(LatLng point) {&amp;#xA;        Log.v(LocationActivity.TAG,&amp;#xA;                &quot;onMapLongClick == &quot; + point.latitude + &quot;,&quot; + point.longitude);&amp;#xA;        CircleOptions circleOptions = new CircleOptions();&amp;#xA;        circleOptions.center(point).radius(GEOFENCE_RADIUS).strokeColor(&amp;#xA;                android.graphics.Color.BLUE).strokeWidth(2);&amp;#xA;        Circle circle = mMap.addCircle(circleOptions);&amp;#xA;        String key = Integer.toString(id);&amp;#xA;        id++;&amp;#xA;        mGeoFences.put(key, circle);&amp;#xA;        addGeoFences();&amp;#xA;    }&amp;#xA;&amp;#xA;    // Creates Geofence objects from all circles on the map and calls addGeofences API.&amp;#xA;    private void addGeoFences() {&amp;#xA;        List&amp;lt;Geofence&amp;gt; list = new ArrayList&amp;lt;Geofence&amp;gt;();&amp;#xA;        for (Map.Entry&amp;lt;String, Circle&amp;gt; entry : mGeoFences.entrySet()) {&amp;#xA;            Circle circle = entry.getValue();&amp;#xA;            Log.v(LocationActivity.TAG, &quot;points == &quot; +&amp;#xA;                    circle.getCenter().latitude + &quot;,&quot; +&amp;#xA;                    circle.getCenter().longitude);&amp;#xA;            Geofence geofence = new Geofence.Builder()&amp;#xA;                   .setRequestId(entry.getKey())&amp;#xA;                   .setTransitionTypes(Geofence.GEOFENCE_TRANSITION_ENTER |&amp;#xA;                                       Geofence.GEOFENCE_TRANSITION_EXIT)&amp;#xA;                   .setCircularRegion(circle.getCenter().latitude,&amp;#xA;                                      circle.getCenter().longitude,&amp;#xA;                                      (float) circle.getRadius())&amp;#xA;                    .setExpirationDuration(Geofence.NEVER_EXPIRE).build();&amp;#xA;            list.add(geofence);&amp;#xA;        }&amp;#xA;        if (list.isEmpty()) {&amp;#xA;            return;&amp;#xA;        }&amp;#xA;        // Clear off all the currently triggering geo_fences before new fences&amp;#xA;        // are added.&amp;#xA;        for (Circle triggeringGeoFence : mTriggeringFences.values()) {&amp;#xA;            triggeringGeoFence.remove();&amp;#xA;        }&amp;#xA;        mTriggeringFences.clear();&amp;#xA;        Log.v(LocationActivity.TAG, &quot;addingGeoFences size = &quot; + list.size());&amp;#xA;        mLocationClient.addGeofences(list, getPendingIntent(), this);&amp;#xA;    }&amp;#xA;&amp;#xA;    private PendingIntent getPendingIntent() {&amp;#xA;        Intent intent = new Intent(ACTION_GEOFENCE);&amp;#xA;        intent.setComponent(new ComponentName(LocationActivity.this,&amp;#xA;                GeoFenceIntentReceiver.class));&amp;#xA;        return PendingIntent.getBroadcast(LocationActivity.this, 0, intent,&amp;#xA;                PendingIntent.FLAG_UPDATE_CURRENT);&amp;#xA;    }&amp;#xA;&amp;#xA;    private void removeGeoFences() {&amp;#xA;        List&amp;lt;String&amp;gt; requestIdsForRemoval = new ArrayList&amp;lt;String&amp;gt;();&amp;#xA;        if (mGeoFences.isEmpty()) return;&amp;#xA;        for (Map.Entry&amp;lt;String, Circle&amp;gt; entry : mGeoFences.entrySet()) {&amp;#xA;            String requestId = entry.getKey();&amp;#xA;            Circle circle = entry.getValue();&amp;#xA;            if (circle != null) {&amp;#xA;                circle.remove();&amp;#xA;                id --;&amp;#xA;                Log.v(LocationActivity.TAG, &quot;RemoveGeoFence requestId == &quot; + requestId);&amp;#xA;                Circle triggeringCircle = mTriggeringFences.get(requestId);&amp;#xA;                if (triggeringCircle != null) {&amp;#xA;                    triggeringCircle.remove();&amp;#xA;                }&amp;#xA;                requestIdsForRemoval.add(requestId);&amp;#xA;            }&amp;#xA;        }&amp;#xA;        mGeoFences.clear();&amp;#xA;        mTriggeringFences.clear();&amp;#xA;        mLocationClient.removeGeofences(requestIdsForRemoval, this);&amp;#xA;    }&amp;#xA;&amp;#xA;    @Override&amp;#xA;    public void onAddGeofencesResult(int statusCode,&amp;#xA;            String[] geofenceRequestIds) {&amp;#xA;        StringBuilder builder = new StringBuilder();&amp;#xA;        for (int i = 0 ; i &amp;lt; geofenceRequestIds.length - 1; ++i) {&amp;#xA;            builder.append(geofenceRequestIds[i]);&amp;#xA;            builder.append(&quot;,&quot;);&amp;#xA;        }&amp;#xA;        builder.append(geofenceRequestIds[geofenceRequestIds.length - 1]);&amp;#xA;        Log.v(LocationActivity.TAG, &quot;Added Geofences == &quot; &amp;#xA;                + statusCodeToString(statusCode) + &quot; &quot; + builder.toString());&amp;#xA;        mGeoFenceStatus.setText(&quot;Added Geofences &quot;&amp;#xA;                + statusCodeToString(statusCode) + &quot; &quot; + builder.toString());&amp;#xA;    }&amp;#xA;&amp;#xA;    private String statusCodeToString(int statusCode) {&amp;#xA;        switch(statusCode) {&amp;#xA;            case LocationStatusCodes.SUCCESS :&amp;#xA;                return &quot;SUCCESS&quot;;&amp;#xA;            case LocationStatusCodes.GEOFENCE_NOT_AVAILABLE :&amp;#xA;                return &quot;GEOFENCE_NOT_AVAILABLE&quot;;&amp;#xA;            case LocationStatusCodes.GEOFENCE_TOO_MANY_GEOFENCES :&amp;#xA;                return &quot;GEOFENCE_TOO_MANY_GEOFENCES&quot;;&amp;#xA;            case LocationStatusCodes.GEOFENCE_TOO_MANY_PENDING_INTENTS :&amp;#xA;                return &quot;GEOFENCE_TOO_MANY_PENDING_INTENTS&quot;;&amp;#xA;            case LocationStatusCodes.ERROR :&amp;#xA;                return &quot;ERROR&quot;;&amp;#xA;        }&amp;#xA;        return &quot;UNKNOWN&quot;;&amp;#xA;    }&amp;#xA;&amp;#xA;    @Override&amp;#xA;    public void onRemoveGeofencesByPendingIntentResult(int statusCode, PendingIntent pendingIntent) {&amp;#xA;        // Do nothing&amp;#xA;    }&amp;#xA;&amp;#xA;    @Override&amp;#xA;    public void onRemoveGeofencesByRequestIdsResult(int statusCode,&amp;#xA;            String[] geofenceRequestIds) {&amp;#xA;        StringBuilder builder = new StringBuilder();&amp;#xA;        for (int i = 0 ; i &amp;lt; geofenceRequestIds.length - 1; ++i) {&amp;#xA;            builder.append(geofenceRequestIds[i]);&amp;#xA;            builder.append(&quot;,&quot;);&amp;#xA;        }&amp;#xA;        builder.append(geofenceRequestIds[geofenceRequestIds.length - 1]);&amp;#xA;        Log.v(LocationActivity.TAG, &quot;Removed Geofence &quot; +&amp;#xA;                statusCodeToString(statusCode) + &quot; &quot; + builder.toString());&amp;#xA;        mGeoFenceStatus.setText(&quot;Removed Geofences request_ids = &quot; +&amp;#xA;                builder.toString() + &quot; &quot; + statusCodeToString(statusCode));&amp;#xA;    }&amp;#xA;&amp;#xA;};&amp;#xA;&amp;#xA;// Triggered when startAcitivity method is called in GeoFenceIntentReceiver.&amp;#xA;// Updates UI as geofences are entered/exited.&amp;#xA;@Override&amp;#xA;protected void onNewIntent(Intent intent) {&amp;#xA;    super.onNewIntent(intent);&amp;#xA;    // getIntent() should always return the most recent&amp;#xA;    setIntent(intent);&amp;#xA;    boolean receiverStarted =&amp;#xA;            intent.getBooleanExtra(&quot;RECEIVER_STARTED&quot;, false);&amp;#xA;    if (!receiverStarted) {&amp;#xA;        return;&amp;#xA;    }&amp;#xA;    Bundle bundle = intent.getParcelableExtra(&quot;geo_fences&quot;);&amp;#xA;    ArrayList&amp;lt;String&amp;gt; requestIds =&amp;#xA;            bundle.getStringArrayList(&quot;request_ids&quot;);&amp;#xA;    if (requestIds == null) {&amp;#xA;        Log.v(LocationActivity.TAG, &quot;request_ids == null&quot;);&amp;#xA;        return;&amp;#xA;    }&amp;#xA;    int transition = intent.getIntExtra(&quot;transition&quot;, -2);&amp;#xA;&amp;#xA;    for (String requestId : requestIds) {&amp;#xA;        Log.v(LocationActivity.TAG, &quot;Triggering Geo Fence requestId &quot;&amp;#xA;                + requestId);&amp;#xA;        if (transition == Geofence.GEOFENCE_TRANSITION_ENTER) {&amp;#xA;            Circle circle = mGeoFences.get(requestId);&amp;#xA;            if (circle == null) {&amp;#xA;                continue;&amp;#xA;            }&amp;#xA;            Log.v(LocationActivity.TAG, &quot;triggering_geo_fences enter == &quot;&amp;#xA;                    + requestId);&amp;#xA;&amp;#xA;            // Add a superimposed red circle when a geofence is entered and&amp;#xA;            // put the corresponding object in triggering_fences.&amp;#xA;            CircleOptions circleOptions = new CircleOptions();&amp;#xA;            circleOptions.center(circle.getCenter())&amp;#xA;                    .radius(circle.getRadius())&amp;#xA;                    .fillColor(Color.argb(100,100, 0, 0));&amp;#xA;            Circle newCircle = mMap.addCircle(circleOptions);&amp;#xA;            mTriggeringFences.put(requestId, newCircle);&amp;#xA;        } else if (transition == Geofence.GEOFENCE_TRANSITION_EXIT) {&amp;#xA;            Log.v(LocationActivity.TAG,  &quot;triggering_geo_fences exit == &quot;&amp;#xA;                    + requestId);&amp;#xA;            Circle circle = mTriggeringFences.get(requestId);&amp;#xA;            if (circle == null) {&amp;#xA;                continue;&amp;#xA;            }&amp;#xA;            // Remove the superimposed red circle from the map and the&amp;#xA;            // corresponding Circle object from triggering_fences hash_map.&amp;#xA;            circle.remove();&amp;#xA;            mTriggeringFences.remove(requestId);&amp;#xA;        }&amp;#xA;    }&amp;#xA;    return;&amp;#xA;}&amp;#xA;&lt;/code&gt;&lt;/pre&gt;&amp;#xA;&amp;#xA;&lt;p&gt;}&lt;/p&gt;&amp;#xA;&amp;#xA;&lt;p&gt;2nd class &lt;/p&gt;&amp;#xA;&amp;#xA;&lt;pre&gt;&lt;code&gt;public class ActivityRecognitionIntentService extends IntentService {&amp;#xA;public ActivityRecognitionIntentService() {&amp;#xA;    super(&quot;ActivityRecognitionIntentService&quot;);&amp;#xA;}&amp;#xA;&amp;#xA;public ActivityRecognitionIntentService(String name) {&amp;#xA;    super(name);&amp;#xA;}&amp;#xA;&amp;#xA;@Override&amp;#xA;protected void onHandleIntent(Intent intent) {&amp;#xA;    if (intent.getAction() != LocationActivity.ACTION_ACTIVITY_RECOGNITION) {&amp;#xA;        return;&amp;#xA;    }&amp;#xA;    if (ActivityRecognitionResult.hasResult(intent)) {&amp;#xA;        ActivityRecognitionResult result = ActivityRecognitionResult&amp;#xA;                .extractResult(intent);&amp;#xA;        DetectedActivity detectedActivity = result&amp;#xA;                .getMostProbableActivity();&amp;#xA;        int activityType = detectedActivity.getType();&amp;#xA;&amp;#xA;        Log.v(LocationActivity.TAG, &quot;activity_type == &quot; + activityType);&amp;#xA;&amp;#xA;        // Put the activity_type as an intent extra and send a broadcast.&amp;#xA;        Intent send_intent = new Intent(&amp;#xA;                LocationActivity.ACTION_ACTIVITY_RECOGNITION);&amp;#xA;        send_intent.putExtra(&quot;activity_type&quot;, activityType);&amp;#xA;        sendBroadcast(send_intent);&amp;#xA;    }&amp;#xA;}&amp;#xA;}&amp;#xA;&lt;/code&gt;&lt;/pre&gt;&amp;#xA;&amp;#xA;&lt;p&gt;edited add the main part of the code &lt;/p&gt;&amp;#xA;" stacktrace="Caused by: java.lang.IllegalStateException: Not connected. Call connect() and wait for onConnected() to be called."/></posts>